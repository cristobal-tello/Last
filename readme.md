# LAST #

## 02. Asset Mapper ##

The AssetMapper component lets you write modern JavaScript and CSS without the complexity of using a bundler. Browsers already support many modern JavaScript features like the import statement and ES6 classes. And the HTTP/2 protocol means that combining your assets to reduce HTTP connections is no longer urgent. This component is a light layer that helps serve your files directly to the browser.

To install:
$ composer require symfony/asset-mapper symfony/asset symfony/twig-pack

After the installation, take a look 'asset_mapper.yaml'

All the directories in 'paths' now will be "public".

eg:
Create new irectory 'images' in 'assets' directory Then copy a image (eg: logo.png).

Using next command-line you will check the 'logical path' for previous new image.

$ bin/console debug:asset

Use the 'logical path' value, eg:

<img src="{{ asset('images/logo.png')}}" alt="Cool logo" />

If you take a look the source, you will note the file is not 'logo.png'. Instead, you open a file with name like this  'logo-3fd04f1b832abdd71143b862bf75ba55.png', but you cannot find this file. This is happen whe you're in debug mode. When you be ready for production, you need to compile the assets and Symfony will do the work for you and we don't need to modify any template.

To compile assets, use:
$ bin/console asset-map:compile

Then, take a look the public/assets/images and the files will be there.

In Dev mode, delete 'public/assets/images' because if there are assets in ''public/assets/images', Symfony will use these assets excepts the assets in the 'assets' directory.

Same occurs with .js files

## 03. Importmap and javascript modules ##

If you take a look the source code, you will see something like this:

<head>
...
<script type="importmap">
{
    "imports": {
        "app": "/assets/app-6295ab64118d8ed1901a31420eb58692.js",
        "/assets/styles/app.css": "data:application/javascript,"
    }
}
</script>
<!-- ES Module Shims: Import maps polyfill for modules browsers without import maps support -->
<script async src="https://ga.jspm.io/npm:es-module-shims@1.8.0/dist/es-module-shims.js"></script>
<link rel="modulepreload" href="/assets/app-6295ab64118d8ed1901a31420eb58692.js">
<script type="module">import 'app';
</script>            
...
</head>

So, by default, we have an app module and it's mapped in the "importmap".

This code is generated by the line:

{% block importmap %}{{ importmap('app') }}{% endblock %}

In 'base.html.twig'. It also uses part of importmap.php

Create a .js file in a new 'lib' directory inside 'assets directory' with next content:

export default function (message, inPeace = false) {
    console.log(`${message}! ${inPeace ? 'ðŸ‘½' : 'ðŸ‘¾'}`);
}

In app.js, add next:

import alienGreeting from './lib/alien-greeting.js'

alienGreeting('Give us a candy', false);

Refresh, an you will note the function is called.

## 04. Install 3rd javascript packages ##

In npmjs.com look for js-confetti. We're going to use it without use yiarn. We focus in the usage example:

import JSConfetti from 'js-confetti'

const jsConfetti = new JSConfetti()

jsConfetti.addConfetti()

We copy the previous code in the app.js file. Just one note, first we need imports and then use functions, eg:

...
import './styles/app.css'
import alienGreeting from './lib/alien-greeting.js'
import JSConfetti from 'js-confetti'

const jsConfetti = new JSConfetti()
jsConfetti.addConfetti()

alienGreeting('Give us a candy', false);
...

To install the library, we need to run:

$ bin/console importmap:require js-confetti

If you take a look, the library code goes to vendor and this directory is in the .gitignore list.

Then, for the future, when you need to install all 3rd party libraries, you will to run:

$ bin/console importmap:install

Also, take a look importmap.php to check how the file changes.